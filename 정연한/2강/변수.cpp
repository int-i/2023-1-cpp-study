#include <iostream>

// using 선언문
// 이 using 선언문은 cin이, 다른 namespace가 아닌 std namespace(스탠다드(표준) 네임스페이스),
// 즉 std::cin으로 사용된다는 것을 컴파일러에 알려준다.
using std::cin;

using std::cout;
using std::endl;

using std::string;



// 변수 선언: 메모리(RAM)에 내가 사용할 수 있게 일정 크기의 공간을 할당받는 것
// 변수를 창고라고 치면, 땅을 임대받아 새 창고를 짓는 행위에 비유할 수 있음

// 변수의 초기화: 메모리 공간을 "할당 받음과 동시에" 그 곳에 있던 쓰레기 값을 치우고 새 값을 넣는 것
// 창고로 치면, 내가 창고를 짓고나서 창고안에 있던 건축 자재들을 치우고, 내가 넣고 싶은 물건을 넣는 행위

// 변수에 값 대입: 기존에 어떤 값이 들어있는 메모리 공간에 새로운 값을 집어넣는 것
// 창고로 치면, 내가 기존에 지었던 창고에 있던 물건들을 빼고 새 물건들을 집어넣는 행위

// 자료형(data type): 데이터의 종류
// 기본적으로 변수를 선언하기 위해선 변수의 이름 앞에 반드시
// 해당 변수에 들어갈 데이터의 자료형을 적어주어야 한다.

// 변수를 선언하는 것은 창고를 짓는것에 비유할 수 있다고 했는데,
// 예를 들어 내가 곰인형을 창고에 넣는다고 치자.
// 그렇다면 창고의 형태도 곰인형을 넣을 수 있는 창고로 만들어야지,
// 뜬금없이 냉동 창고를 만들어 버리면 안되는 것이다.


int main() {
	int i = 0; // 4바이트 정수 최대값: 2,147,483,647

	float f = 0.0f; // 4바이트 실수(단정밀도 부동 소수점)

	double d = 0.0; // 8바이트 실수(배정밀도 부동 소수점)

	bool b = true; // 1바이트 논리 자료형 변수에 0이 들어오면 false
	// bool 자료형 변수에 0 이외의 값이 들어오면 true


	// 문자는 반드시 홑따옴표로,
	// 문자열은 반드시 쌍따옴표로 선언해주어야 한다.
	// 문자는 말 그대로 하나의 문자(charactor), 문자열은 여러 문자들이 배열된 것
	char c = 'a'; // 1바이트 문자(실제 메모리에는 해당 문자에 매칭되는 정수값으로 저장 됨)

	char str1[] = "abc"; // 기존 C 스타일 문자열
	string str2 = "abc"; // C++ 스타일 문자열

	// 대괄호: 배열
	// "abc" 대신 { 'a', 'b', 'c' } 이렇게도 넣을 수 있다.


	// 변수에 값 대입
	// 자리수 구분은 홑따옴표(')를 사용해 구분할 수 있다.
	i = 2'147'483'647;

	// int 최대값에 1을 더해보자.
	// 오버플로우가 일어나 -2,147,483,648이 나오게 된다.
	cout << i + 1 << endl;

	return 0;
}


// 1바이트 == 8비트
// 1비트가 표현할 수 있는 값 == 2개(0과 1)
// 전기가 통하면 1, 전기가 통하지 않으면 0
// 이게 컴퓨터가 1비트를 인식하는 방법

// 1바이트가 표현할 수 있는 값 = 2^8
// 왜이렇게 되는가
// 1비트 = 0, 1
// 2개 == 2^1
// 2비트 = 00, 01, 10, 11
// 4개 == 2^2
// 3비트 = 000, 001, 010, 011, 100, 101, 110, 111
// 3비트 변수값 111에 1을 더하게 되면?
// 8개 == 2^3
// 4비트
// 16개 == 2^4
// ...
// 8비트 = 00000000, 00000001, 00000010, ..., 11111110, 11111111, 
// 
// 256개 == 2^8

// 1100(2) == 12
// 오버플로우가 나면 음수가 나오는 이유 = 컴퓨터가 음수를 표현하는 방법 때문에
// 일반적으로 변수를 선언하면, 그 맨 앞에 있는 비트(최상위비트)는 부호 비트라고 '약속'
// 개발자들이 그렇게 정함
// 예를 들어 8비트(== 1바이트) 변수을 선언했다고 가정,
// 10000000 음수
// 00000000 양수
// 01111111 == 127 == 양수값
// 10000000 == -128 == 음수값
// 10000001 == -127
// 10000010 == -126
// ...
// 11111110 == -2
// 11111111 == -1
// 00000000 == 0

// 1바이트로 나타낼 수 있는 값의 범위: -128 ~ 127
// 1바이트로 나타낼 수 있는 총 값의 개수: 256

// 1바이트 변수에 들어간 127이란 값에 1을 더해주겠다.
//  10
//   10
//    10
//     10
//      10
//       10
//        10
//  01111111 == 127
// +       1
// ----------
//  10000000 == 부호비트가 1 == 음수
// 부호비트 아래의 7비트 값들이 전부 0 == 7비트로 나타낼 수 있는 음수값 중 가장 작은 값 == -128


// 3비트로 줄여서 보면
// 3비트로 나타낼 수 있는 값의 범위 = -4~3
// 2^3 == 8개
// 0을 양수 취급하기 때문에 양수의 범위는
// 해당 변수가 나타낼 수 있는 최대값 / 2 - 1 이 되는 것이고
// 음수는 그런 거 없으니까 그냥 최대값 / 2가 되는 것이고
// 000 == 0
// 001 == 1
// 010 == 2
// 011 == 3
// 100 == -4
// 101 == -3
// 110 == -2
// 111 == -1
// 000 == 0

// 1비트 == 1/8바이트
// 1바이트(B) = 8비트(b)
// 1킬로바이트(kB) == 1024B == 2^10B
// 1메가바이트(MB) == 1024kB == 2^10kB
// 1기가바이트(GB) == 1024MB == 2^10MB
// 1테라바이트(TB) == 1024GB == 2^10GB
// 1페타바이트(PB) == 1024TB == 2^10TB

// 1Gbps == 1 기가비트 퍼 세컨드 == 최대 1초에 1기가비트(128메가바이트)를 전송한다
// 1Gb == 1024Mb == 2^10 * 2^10kb == 2^10 * 2^10 * 2^10b
// 1Gb == 1/8GB == 128MB

// 여기까지가 데이터의 단위
