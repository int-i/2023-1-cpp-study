#include <iostream>
using std::cin;
using std::cout;
using std::endl;

using std::string;

// 상속
// 상속은 객체 지향 프로그래밍 4요소 중 하나
// 어떤 두개의 클래스를 부모 클래스와 자식 클래스로 이어주는 역할
// 부모 클래스 대신 기반(base) 클래스, 자식 클래스 대신 파생(derived)클래스 라고도 함.
// 생물 분류 단계가 이와 유사하다 볼 수 있다.
// 
// 자식 클래스는 부모 클래스의 모든 내용을 상속받는다
// 상속 받은 자식 클래스에선 부모 클래스의 메서드를 오버라이딩 할 수 있음.
// C++ 기준으로 하나의 자식 클래스는 여러개의 부모클래스를 상속받을 수 있음
// 단, 죽음의 다이아몬드라 불리는 고착상태에 빠질 수 있기 때문에 권장되지 않음
// 이를 해결하기 위해 트레이트(traits)나 믹스인(mixin) 등의 기술이 사용 되기도 한다.
//
// 상속을 한 클래스와 상속을 받은 클래스 사이의 관계는 is-a 관계라고 한다.
// 예를 들어 포유류 is a 동물(포유류는 동물이다)
//
// 만약 클래스나 상속을 쓰지 않았다면, 사소한 수정 사항이라도 발생할 경우
// 모든 객체의 코드를 일일이 찾아다니며 수정을 해야 하지만,
// 상속을 쓰면 그냥 상속 받은 클래스에 새로운 변수를 하나 추가하거나,
// 재정의(오버라이딩) 같은 기능을 이용해서 입맛에 맞게 바꿔줄 수도 있다.


// 부모 클래스
class 동물 {
public:
	// 기본 생성자: 매개변수가 하나도 없는 생성자
	동물()
		// 멤버 이니셜라이저
		// 멤버 이니셜라이저는 생성자의 본문이 실행되기 전,
		// 객체가 생성될 때에 멤버를 초기화한다.
		// 
		// 반드시 멤버 이니셜라이저로 초기화해야 되는 것은 아래 4가지 경우이다.
		// 상수 멤버, 레퍼런스 멤버, 멤버의 생성자를 호출해야 될 때,
		// 부모의 생성자를 호출해야 될 때
		: 다리_개수{ }, 털_유무{ }, 아가미_유무{ }, 날개_유무{ }, 서식지{ }
	{ }


	// 위와 동일한 생성자지만 멤버 이니셜라이저를 쓰지 않고 생성자 본문에서
	// 멤버들을 초기화 할 수 있다.
	// 그러나 이 경우 직접 초기화를 할 수 없고 복사 초기화만 가능하다.
	// 위의 초기화 방식은 엄밀히는 직접 초기화 방식의 유니폼 초기화이고,
	// 아래의 초기화 방식은 복사 초기화 방식의 유니폼 초기화이다.
	// 상황에 따라 직접 초기화가 좀 더 빠르긴 하지만,
	// 보통 두 방법 중 하나를 선택하는 것은 코드 가독성과 스타일의 문제이다.
	/*동물() {
		다리_개수 = { };
		털_유무 = { };
		아가미_유무 = { };
		날개_유무 = { };
		서식지 = { };
	}*/

	// 기본 생성자를 오버로딩 한 생성자
	// 함수 오버로딩: 동일한 이름의 함수를 여러개 선언하는 것
	// 따라서 같은 이름의 함수를 호출할 때, 넣어주는 인자값에 따라서 다른 함수를 호출하게 된다.
	// 함수 오버로딩은 매개변수가 다를때만 성립하고, 반환형은 신경쓰지 않는다.
	// ex) int sum(int, int); double sum(double, double);
	// sum(10, 40); sum(3.14, 5.78);

	// 생성자 오버로딩
	동물(int 다리_개수, bool 털_유무, bool 아가미_유무, bool 날개_유무, string 서식지)
		: 다리_개수{ 다리_개수 }, 털_유무{ 털_유무 },
		아가미_유무{ 아가미_유무 }, 날개_유무{ 날개_유무 }, 서식지{ 서식지 } { }

	//동물(int 다리_개수, bool 털_유무, bool 아가미_유무, bool 날개_유무, string 서식지) {
	//	this->다리_개수 = 다리_개수;
	//	this->털_유무 = 털_유무;
	//	this->아가미_유무 = 아가미_유무;
	//	this->날개_유무 = 날개_유무;
	//	this->서식지 = 서식지;
	//}

	// 메서드
	void 특징() {
		cout << "동물의 특징: "
			<< "운동성이 있고, 세포호흡을 하며, 유성생식이 가능한 생물" << endl;
	}

private:
	int 다리_개수;
	bool 털_유무;
	bool 아가미_유무;
	bool 날개_유무;
	string 서식지;
};

class 포유류 : public 동물 {
public:
	포유류()
		// 이처럼 상속을 받은 경우 부모 클래스가 가지고 있는 멤버를
		// 초기화 해줘야 하기 때문에,
		// 멤버 이니셜라이저를 통해 익명의 부모 클래스의 객체를 생성하여,
		// 해당 멤버들을 초기화 해준다.
		: 동물{ 4, true, false, false, "땅" }, 울음소리{ } { }

	// 이처럼 부모 클래스의 특징 이라는 메서드를 상속받고,
	// 그것을 오버라이딩 해줄 수 있음
	// 오버라이딩: 덮어쓰기
	// 부모 클래스에 같은 이름의 클래스가 있더라도,
	// 자식 클래스에서 그 내용을 덮어써서 다른 코드를 실행시킬 수 있다.
	void 특징() {
		cout << "포유류의 특징: "
			<< "유선이 있어 새끼들에게 젖을 먹이며 키우는 것이 특징" << endl;
	}


private:
	string 울음소리;
};


int main() {
	// 객체를 선언할 때, 호출 되는 생성자는
	// 객체 선언시 인자값으로 넣어준 값들의 자료형에 따라 달라진다.
	동물 동물1{ };

	포유류 포유류1{ };


	동물1.특징();

	포유류1.특징();

	return 0;
}

